using Godot;
using System.Collections.Generic;
using System.Linq;


public class WeightedSequence
{
    private class Node
    {
        public Spatial Data { get; }
        public float Weight { get; }
        public Node Next { get; set; }

        public Node(Spatial data, float weight)
        {
            Data = data;
            Weight = weight;
            Next = null;
        }
    }

    private Node head;

    public void Add_Element(Spatial data, float weight)
    {
        Node newNode = new Node(data, weight);

        if (head == null || head.Weight > weight)
        {
            newNode.Next = head;
            head = newNode;
        }
        else
        {
            Node current = head;

            while (current.Next != null && current.Next.Weight <= weight)
            {
                current = current.Next;
            }

            newNode.Next = current.Next;
            current.Next = newNode;
        }
    }

    public Spatial Pop()
    {
        Spatial result = head.Data;
        head = head.Next;
        return result;
    }

	public bool IsEmpty()
    {
        return head is null;
    }
}


public class Pathfinder : Node
{
	
	private Dictionary<Spatial, List<Spatial>> graph;
	private Dictionary<(Spatial, Spatial), float> distances;

    private Dictionary<Spatial, List<string>> node_to_groups;
	private Dictionary<string, List<Spatial>> group_no_node;


	public override void _Ready()
	{
		graph = new Dictionary<Spatial, List<Spatial>> {};
		distances = new Dictionary<(Spatial, Spatial), float> {};
        node_to_groups = new Dictionary<Spatial, List<string>> {};
        group_no_node = new Dictionary<string, List<Spatial>> {};
	}
    public void Set_group(Spatial node, string name){

    }

	public void Register_bind(Spatial start, Spatial end, float distance){
		if (graph.Keys.Contains(start)){
			if (!graph[start].Contains(end)){
				graph[start].Add(end);
			}
		} else {
			graph.Add(start, new List<Spatial> {end});
		}
        if (!distances.Keys.Contains((start, end))){
            distances.Add((start, end), distance);
        }
		

		if (graph.Keys.Contains(end)){
			if (!graph[end].Contains(start)){
				graph[end].Add(start);
			}
		} else {
			graph.Add(end, new List<Spatial> {start});
		}
        if (!distances.Keys.Contains((end, start))){
            distances.Add((end, start), distance);
        }
	}

    public void Erase_point(Spatial point){
        if (graph.Keys.Contains(point)){
            foreach (var end in graph[point]){
                if (graph[end].Contains(point)){
				    graph[end].Remove(point);
			    }
                if (distances.Keys.Contains((point, end))){
                    distances.Remove((point, end));
                }
                if (distances.Keys.Contains((end, point))){
                    distances.Remove((end, point));
                }
            }
            graph.Remove(point);
		}
    }

	public void Break_bind(Spatial start, Spatial end){
		if (graph.Keys.Contains(start)){
			if (graph[start].Contains(end)){
				graph[start].Remove(end);
			}
		}
		if (graph.Keys.Contains(end)){
			if (graph[end].Contains(start)){
				graph[end].Remove(start);
			}
		}
        if (distances.Keys.Contains((start, end))){
            distances.Remove((start, end));
        }
        if (distances.Keys.Contains((end, start))){
            distances.Remove((end, start));
        }
	}

	public List<Spatial> Shortest_path(Spatial startVertex, Spatial endVertex)
    {
        if (!(graph.Keys.Contains(startVertex) && graph.Keys.Contains(endVertex))){
            return new List<Spatial> {};
        }
        WeightedSequence sequence = new WeightedSequence();
        Dictionary<Spatial, Spatial> parent = new Dictionary<Spatial, Spatial>();
        Dictionary<Spatial, float> visited = new Dictionary<Spatial, float>();

        sequence.Add_Element(startVertex, 0);
        visited[startVertex] = 0;

        while (!sequence.IsEmpty())
        {
            Spatial currentVertex = sequence.Pop();
            
            foreach (var neighbor in graph[currentVertex])
            {
                float dist = visited[currentVertex] + distances[(currentVertex, neighbor)];
                if (!visited.ContainsKey(neighbor))
                {
                    sequence.Add_Element(neighbor, dist);
                    visited[neighbor] = dist;
                    parent[neighbor] = currentVertex;
                }
                else {
                    if (visited[neighbor] > dist){
                        visited[neighbor] = dist;
                    }
                }
            }
        }

        // Reconstruct the path
        List<Spatial> shortestPath = new List<Spatial>();
        Spatial tempVertex = endVertex;
        if (!parent.Keys.Contains(tempVertex)){
            return new List<Spatial> {};
        }
        while (tempVertex != startVertex)
        {
            shortestPath.Add(tempVertex);
            tempVertex = parent[tempVertex];
        }

        shortestPath.Add(startVertex);
        shortestPath.Reverse();

        return shortestPath;
    }
}
